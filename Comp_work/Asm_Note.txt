dos环境，debug调试，masm微软编译器
debug 文件.exe

数据类型
	字节byte，8比特；
	字word，2字节；
	双字Dword，2字；

※数制和编码
进制转换：
	2转10；10转2（整数、小数）
DOS下debug的运行
	查看内存内容 D 开始地址 结束地址
	数字默认十六进制
编码：
	无符号、补码、ascii
	10->2进制转换的过程，可以视为位运算：正->负，负->正都是取反加一
	补码运算的特性：	加减可以编码直接相加（与无符号数加减法运算规则相同）
					补码运算和无符号数采用不同的溢出判断（比如同号补码相加，首位与加数不同时溢出（即加到负数部分了））
	ascii：7位二进制码，用一字节表示一个ascii码，首位0

debug指令
（下述地址范围均有两种表示方式：1）始末，2）起始 L长度）
	R 显示出CPU内部所有寄存器的内容和标志位状态
		R 寄存器 可以查看并修改寄存器中的内容
		R F 可以查看flags并修改，直接输入修改后的指令
	D 地址\地址范围 显示指定地址内容
	F 开始地址 0a结束地址 数据：写入数据（可以写入串）
		F 2000:0100 L10 "Hello, World!",0d,0a,’$’
		段地址、偏移地址、十个字节、0d0a回车、换行、$终止符（写入,用于在ah,9时终止）
	A 偏移地址 输入汇编指令，转为机器码，存到cs:偏移地址（地址缺省从当前ip开始）
	U 地址\地址范围 反汇编；前者反编译32个字节；缺省地址从上次反汇编的末尾下一位开始
	G[=起始地址] [断点地址] 从起始地址（若缺省，从当前ip）开始运行到断点地址；若缺省断点，则连续运行程序
	P[=地址] 单步执行（p=100，从100开始单步执行）
	T[=地址] [值] 从当前ip开始到【地址】停下,不执行【地址】对应的指令；缺省地址时单步执行，进入子程序（P不进入子程序）
		如果不缺省【值】，则从【地址】开始，以单步方式运行【值】步
		-t后出现 STI 提示，表示set interrput flag，启用中断；IRET提示表示interrupt return从中断回到元累的程序执行点，中断结束；
	INT 21：用于提供DOS系统功能的调用（注意依然要通过调用程序来启动）
		当执行INT 21H时，根据AH中的内容，进行不同的功能调用（进入子程序）
		01H：输入一个字符，回显并存储到AL
		02H：输出DL中的字符（输出到屏幕、同时输出到al）
		08H：输入一个字符，无回显并存储到AL
		09H：输出一个字符串，字符串起始地址由DS:DX给出，字符串以‘$’结束，不输出$
		0AH：读入字符串（以回车结束），字符串起始地址由DS:DX给出(段地址要先写入寄存器，再写入ds。直接写写不进去）
			这里对ds：dx开始的一段内存空间有要求：要由三个变量构成：第一字节变量：给出缓冲区最大值 第二字节变量用以填写实际长度 第三变量用来存储字符串
		0BH：检查是否有字符可读取
		4CH：退出
	int 3：中断指令

XOR：	和1异或，表现为取反
		和0异或，表现为不变

32位处理器提供了三种模式：
	实模式，即相当于高速运行的8086芯片；
	保护模式；
	模拟8086模式，即在保护模式下，模拟多个8086处理器工作；

控制器
	功能：fetch decode execute
	ip指向下一条指令；

对于补码
	对于加法，只有同号相加才导致溢出；且当同号相加，符号位变化时溢出
	对于减法，同号相减不会溢出；异号相减时，结果与被减数符号位不同时溢出（0111-1000=10111-1000=1111）7-（-8）=15，这里1111=-1出错

这里考虑8086处理器（32位，32位cpu有16个基本寄存器）
	基本寄存器：通用寄存器、段寄存器、指令指示寄存器、标志寄存器
	ax-di ds\es\ss\cs ip nv\up\...\po

通用寄存器：各有用途
	数据寄存器：8/16/32位
		al,ax,eax：累加器，主要用于算术运算结果的记录
		bx,ebx：基址寄存器，存EA中的基址部分；可存数据\地址
		cl,cx,ecx：计数器
		dl,dx,edx：数据寄存器

	指针寄存器：16/32位
		sp\esp：指向堆栈栈顶，专用
		bp\ebp：基址指针，指向栈的某个地方；
				存放内存中数据的偏移地址EA的基址部分，
				也可以存数据

	变址寄存器：16/32位
		可存数据\地址，存放偏移量（相对于基址寄存器）
		si\esi：源变址寄存器
		di\edi：目标变址寄存器

	控制寄存器 16/32位
		ip\eip：指向下一个指令位置
		flags\eflags：cpu当前状态：alu状态、系统状态等；不同位存不同标识，有的位空
			*CF：最高位进\借位（如0001 -1111,0001不够大，要借位）标志，无符号数的溢出标志；
			*ZF：零标志，标志上一次运算结果是否为0；
			*SF：符号标志，负1正0；
			*OF：超出补码范围，有符号数的溢出标志（有符号数溢出，主要看符号位的特殊变化）；
			PF：运算结果中1的个数的奇偶性，偶置1（parity奇偶性）
			AF：加法或减法计算时，最低四位向高位有进位\借位时置1
			IF：允许\禁止cpu响应中断请求
			DF：方向控制：串指令的处理方式（加\减），即指针往内存增加\减少方向移动
			TF：调试程序，TF=1则每执行一次，单步中断一次

	段寄存器：16位
		段：连续的内存单元；段寄存器：存放知识段首地址的相关内容
			CS(Code Segment)，指示代码段
			DS(Data Segment)，指示数据段
			SS(Stack Segment)，指示堆栈段
			ES(Extra Segment), FS, GS，指示附加段
		
内存
	寻址空间：受限于地址总线宽度；每字节有一个地址
	存放格式：小端格式（低位存入），即数值的低位存储在内存的低位
		例：5678h存在100号、101号地址时
			78h存在100号，56存在101号
	地址形式：段：偏移地址（段寄存器存储了基址）
		通过移位来合成段和偏移地址
			16位实模式：20bit地址的合成：段地址*16+偏移地址
			32位保护模式：物理地址规则比较复杂
	
I\O端口
	输入动作转化为编码，存在接口寄存器中；输出同理反向
		端口地址常用dx存,范围是16位
	接口寄存器称为I/O端口
	BIOS：	系统硬件制造商将常用的功能模块，固化在ROM中，
			形成BIOS (Basic Input/Output System)   

堆栈相关
	栈底固定为栈区的最高地址单元
		执行PUSH操作后，(E)SP向低地址方向移动
		执行POP操作后，(E)SP要向高地址方向移动

mov byte ptr [0b00],80
	将80H 按byte ptr（一个字节）方式，写入DS:0b00指定的字节内
	比如，如果是word ptr,则ds：0b00开始的两个字节写入80H，即00 80

内存单元的表示
	类似[0100]为内存单元；具有类型（即长度,byte\word\dword）
	[0100]是段偏移的，默认DS（即若没有给出段地址，上述[0100]指定DS:0100）

操作数寻址（从哪里存取）
	存取方式	立即操作数（一个给出的常数）、寄存器操作数、内存操作数
			通过寄存器比通过内存访问要快；
			在汇编源程序中，用符号表示内存单元
	源操作数（上述三个）、目的操作数（上述后两个）
	一般，一个指令的各个操作数类型相同(长度相同)

（内存操作数的）选址方式
	*（偏移地址）EA：基址+变址+位移量
	CPU以 段:EA 寻址内存（注意小端存储）
		1）	直接寻址：直接给出EA，例[1000h]，默认DS段；可以改变默认段 ES:[1000h]
		2）	寄存器间接寻址：EA存在BP、BX、SI、DI中，用寄存器间接访问EA
				例：MOV [BX]，AX（要用[]括存有EA的寄存器：[BX]表示以BX中内容为地址的内存）
			涉及[]的式子，表示一个内存单元；这个含[]式子描述内存单元的地址
				默认段寄存器ds。例外：以BP寻址，默认用段寄存器SS
				也可以改变默认段 ES:[BP]
		3）	寄存器相对寻址：寄存器存放位置量，EA=位置量+相对量
				例：MOV 4[BX],AX，EA=[BX]+4
					MOV AX,[BP+ -2 ]，EA=[BP]-2
		4）	基址变址寻址：EA=基址寄存器+变址寄存器
				基址：bx、bp；变址：si、di
				格式：[基址寄存器][变址寄存器]、[基址寄存器+变址寄存器]
		5）	相对基址变址寻址：EA＝基址寄存器 + 变址寄存器 + 位移量
				基址、变址同上
				格式：disp[基址寄存器][变址寄存器]、[基址寄存器+变址寄存器+disp]
		
		一个寄存器、一个寄存器加一个数字、两个寄存器、两个寄存器加一个数字
		也可以用 变量[num] 的方式（？）
			L+1可以写成L[1]（另一种表达方式，），注意，L[1]是L的偏移地址加1而不是加1×4	
			此方式不在上述5中之内，且用的是变量的ea放入式子中		


基本指令
	数据传输、算术运算、逻辑运算、控制转移等

指令操作数
	一般情况下，指令的源、目的操作数类型要一致
	如果一个有类型一个没有，以存在的类型推断未指定类型的数据
		例：MOV AX,1234H中，前者指定2字节类型，后者未指定，则认为后者也是2字节
	如果类型均不明确，用ptr指定类型
		例：MOV EAX, DWord Ptr [1000h]
	
通用数据传送指令：数据传输指令均不影响标志位
	MOV 目的，源 ：将源操作数传送到目的存储单元
		内存不能直接存到内存，立即数不能直接存到段寄存器；
		此外，由立即数、寄存器、内存 可以存到寄存器、内存、段寄存器	
			关于段寄存器：寄存器、内存可以写入段寄存器；段寄存器可以写入寄存器
	
	XCHG 操作数1 操作数2：将操作数1与操作数2互换
		可以内存<->寄存器，寄存器<->寄存器，不能内存<->内存

	PUSH 源操作数：数据进栈（根据源操作数大小，esp栈顶指针会减小）
		可以寄存器、内存、段寄存器、立即数（8086不支持立即数）
		进栈数据必须是16\32位的（8086只能16位）（必须类型明确：例：125h不行）
		按小端方式存在栈中
	
	POP 目的操作数：从栈中弹出数据到目的操作数所确定的单元中（根据目的操作数大小，esp栈顶指针会增加）
		格式：POP  reg/mem/seg
		出栈数据必须是16\32位的（8086只能16位），根据目的操作数决定pop16\32位
		数据还在，指针变了
		（可用于组合16位数据，存入EAX等中）
		
地址传送指令
	LEA 目的（寄存器） 源（内存）：将内存的EA存到寄存器中
		若是16位寄存器则只装入EA的低16位
	例：
		(1) LEA	AX, [EBX][ESI]		指令(1)取源操作数的EA，并存入AX
		(2) MOV	AX, [EBX][ESI]		指令(2)取EA所对应的单元内容放入AX 

标志位传送指令
	PUSHF：flags入栈
	POPF：出栈入flags
	LAHF：将FLAGS的低8位送至AH
	SAHF：将AH内容送至标志寄存器低8位
	
CBW
	convert byte to word：将AL的最高位扩展到AH
CWD
	convert word to dword：将AX的最高位扩展到EAX

输入输出指令
	IN/OUT 读写I/O端口，只能使用al\ax\eax收发数据，数据大小由累加器大小决定
	IN 累加器 端口地址：将1/2/4字节端口数据输入AL/AX/EAX
		端口有imm和dx形式，都是指定的端口名；前者范围0~ffh，后者0000~ffffh
	OUT 端口 累加器：AL/AX/EAX内容输入1/2/4字节端口
		端口有imm和dx形式，都是指定的端口名；前者范围0~ffh，后者0000~ffffh
	数据来源和去向都是接口寄存器

ADD 操作数1，操作数2：二者相加，存入操作数1，并设置标志位
	（注意，如果是+指令，一定是常数间运算，在汇编过程中完成了）

数据定义
	s1 type 数据	//s1类似type的数组
	（或者 s1 type num DUP(?)表示num个type构成的，以dup后内容组成的数组（？是占位符，不初始化，但在DOS下置零））
	数据类型包括 db，dw，dd

名 EQU 表达式（例 $-s1,s1是另一个变量名，$指向变量末尾）
	EQU理解为#define

结束源程序与执行入口
	END后面可附带一个在程序中已定义的标号
	用以说明程序的在调入时开始执行的第一条指令所在位置.
	同时，须在程序中通过操作系统的相关功能调用来结束其运行
		如 mov ah 4c，int 21
	START指出程序开始时第一条指令

cmd中，进入masm文件夹后
	输入edit .asm文件 可以编辑

loop指令根据cx的值决定是否继续循环（每次循环自动-1）
	next
	loop next

指令：
	读入字母：MOV AH 1,int 21h
	小写变大写：sub al，32
	输出：	MOV dl，al
			mov ah 2
			int 21h

注释：；分号后是注释

源程序应包括堆栈段、数据段、代码段
	堆栈段：	分配堆栈大小，并用符号表示最高栈单元，指示栈顶位置（用于sp赋值）
		堆栈名 segment stack 
			类型 			大小 内容
			名（TOS为例） 	类型 内容 （用来指示栈顶位置）
		堆栈名 ends
		（在code段中设置堆栈时（即设置ss、sp时），需要停止响应中断）
			CLI
			MOV	AX, _STACK		; 取堆栈内存区段地址
			MOV	SS, AX			; 设置堆栈段寄存器
			MOV	SP, Offset TOS	; 取TOS的偏移部分
			STI			
	数据段：(略)		
	代码段：
		code segment
			assume cs:code,ds:data
			start:
			[codes]
		code ends
			end start

常数：
	debug默认十六进制；源程序默认十进制
	字符串常数：用引号括起来的多个字符，数值是ascii码

变量：存放数据的内存单元名称，用变量名表示（变量名是符号地址）
	[变量名]  数据定义伪指令  初值表  ，即可以没有变量名；
	如果有变量名，那么它仅代表所定义的数据存储区的第一个单元地址；如果有多个内容，可以通过 变量[数\寄存器]的方式访问	
	用DB、DW、DD、DF、DQ、DT 定义并分配1个或多个1B、 2B、 4B、 6B、8B、 10B类型的存储单元
	如果有多个连续变量，地址连续分布
	初值表：
		用逗号连接的多个常数\常数表达式\字符串常数（会按照指定的数据类型做分割）
		分配存储单元但不初始化；一般程序会填充0
		地址表达式 分配存储空间存储地址
			Msg 	DB	"Hello" 13, 10, "$"
			p1		DW	Msg, Msg+5		会将msg的地址写入p1
		n dup('STRING') 将某项(STRING)重复n次；dup(数字)，数字不能超过255
		字符串常数的LENGTH和SIZE均为0
		如果DW 'AB',则B在前，A在后（小端存储）；DW 'a' 也是视为小端
		不可以DW 'dsafsdfas';可以DB 'ABCD';可以DW 'AB';可以DW 'A'


变量属性
	地址属性：
		SEG返回段地址		SEG msg	(变量名)
		OFFSET返回偏移地址
	类型属性
		用 类型 Ptr 指定类型
		TYPE返回占用的字节数
		L是变量，L+1可以写成L[1]，L[1]是L的偏移地址加1而不是加1×4

标号：代表其后首条指令的地址
	标号名:
	具有地址、类型属性；分别用SEG、OFFSET、NEAR、FAR访问属性

表达式和运算符
	在汇编过程中计算完成

伪指令
	汇编期间，指定汇编程序处理源程序的操作，不产生机器代码
	.386:在所有代码之前，通过选择指令集增加伪指令(386指令集要用16位地址模式)
	段定义伪指令
		段名 SEGMENT [定位类型] [组合方式] [地址模式] ['分类名']
		…
		段名 ENDS
			定位类型：内存中起始位置的对齐方式，即偏移地址需要是类型的倍数
			组合方式：略，见ppt
			地址模式：决定地址位数16\32
			分类名：连接程序把不同模块中分类名相同的段组织成一类，存放在连续的存储区域。

	ASSUME段寄存器名:段名 [段寄存器名:段名, …]
		此伪指令用来设定段寄存器和段之间的关联关系。
		以便汇编程序在汇编源程序期间能正确确定指令要访问的是哪个段，如何访问。 
		但是为了能够访问到具体的段地址（汇编程序不会自动填充到ds、ss、es）中，需要在cs中人工写入

	数据定义伪指令
		见变量定义

	符号定义伪指令：为常量、表达式及其他符号定义一个符号名，供以后引用。
		名字 EQU 符号串
		名字 = 表达式 （可以多次定义，以最后一次为准）
		不存储在内存

地址计数器：地址计数器指示当前正在处理的汇编指令或伪指令所在处（首字节）的偏移地址。
	地址计数器的内容用“$”来表示，可以直接用$来引用地址计数器的值
	$引用的是，运行时的包含$的语句的，使用$时的偏移地址；
	(*)$是运行时的量

	定位伪指令ORG
		将地址计数器设置到指定的位置，也可以用在代码段中

	EVEN伪指令
		格式：EVEN
		功能：使下一个变量或指令开始于偶数地址处

	ALIGN伪指令
		格式：ALIGN 2n形式的常数。
		功能：使下一个变量或指令开始于2n整数倍地址处

	子程序名定义与proc和endp
		子程序名 PROC　[NEAR/FAR] 
　		… ;子程序体   
		子程序名 ENDP
	子程序名是子程序的入口地址的符号表示，是符号地址，也具有地址属性和类型属性

运算指令（可见一般不影响df、if）
	算术运算：
	加法
		ADD 操作数1，操作数2：相加存到操作数1
			ADD reg, reg/mem/imm；	ADD mem, reg/imm
			根据结果改变标志位CF, AF, PF, ZF, SF, OF
		ADC 操作数1，操作数2：相加再加CF存入目的操作数（用到的是上次的cf）
			ADD reg, reg/mem/imm；	ADD mem, reg/imm
			根据结果改变标志位CF, AF, PF, ZF, SF, OF
		（由于用到的是上次的cf，可以用来作64位相加，先低位后高位）
		INC 操作数：操作数自增1
			INC reg/mem
			影响AF, PF, ZF, SF和OF，不影响cf
			一般用于指针
	减法
		SUB 操作数1 操作数2：1-2存入1
			SUB reg, reg/mem/imm；
			SUB mem, reg/imm
			根据结果改变标志位
		SBB 操作数1 操作数2：1-2-cf存入1
			寻址、置位同上
		DEC 操作数：操作数自减1
			影响AF, PF, ZF, SF和OF，不影响cf

	NEG 操作数：视为补码并取反（具体来说，取反加一）
		NEG reg/mem
		影响CF, AF, PF, ZF, SF, OF：只有当操作数为0时，才使CF＝0，其他情况则均为1；可见强调对无符号数溢出的指示
		只有当操作数为-27(8位运算)或-215(16位运算)或-231(32位运算)时，才使OF＝1，其他情况则均为0（即仅当负下限取反时溢出）

	CMP 操作数1，操作数2：比较大小，设置标志位
		CMP reg, reg/mem/imm；
		CMP mem, reg/imm。
		具体操作同SUB，但相减结果不保存，只影响标志位（从而可以通过sf判断差的正负）

	乘法
		MUL无符号数乘法、IMUL有符号数乘法（补码）
		MUL/IMUL 源操作数：AL×源操作数存入ax；AX×源操作数存入DX:AX；EAX×源操作数存入EDX:EAX
			注意指定源操作数数据类型： word ptr [100h]
			寻址：MUL/IMUL reg/mem
			二者区别在于看待操作数的方式
			只影响cf、of：mul下，高位为0，cf、of均为0；反之为1
						 imul下，高位为低位符号扩展（即低位足够表示）则cf、of为0；反之为1
				即cf、of=1时，高位出现有效数字（而非符号位）
	除法
		DIV无符号数除法、IDIV有符号数除法
			要求被除数的位数必须是除数的两倍（指数据类型）
		DIV/IDIV 源操作数：
			具体操作：	AX÷源操作数，商入AL, 余数入AH
						DX,AX÷源操作数,商入AX,余数入DX
						EDX,EAX÷源操作数,商入EAX,余数入EDX
			寻址：DIV/IDIV reg/mem
		注：余数符号与被除数符号相同
			可能导致两类错误：除数为零，商溢出
			除法指令对所有标志位无定义 

逻辑指令
	逻辑指令包括逻辑运算指令和移位指令
逻辑运算
	AND 目的操作数，源操作数：按位与，存入目的
		AND reg, reg/mem/imm；
		AND mem, reg/imm
		根据结果置SF, ZF和PF，CF=0，OF=0，AF无定义
	OR 目的操作数，源操作数：按位或，存入目的
		OR reg, reg/mem/imm；
		OR mem, reg/imm
		根据结果改SF, ZF和PF，CF=0，OF=0，AF无定义 
	NOT 目的操作数：按位取反，存入目的
		NOT reg/mem
		不影响标志位 
	XOR 目的操作数，源操作数 ：按位异或，存入目的
		XOR reg, reg/mem/imm
		XOR mem, reg/imm
		根据结果设置SF, ZF和PF，CF=0，OF=0，AF无定义
	TEST 目的操作数，源操作数：
		同AND，但是不保存结果
	常用于设置指定位：AND置0，OR置1，XOR取反
		AND 1不变，OR 0不变，XOR 0不变；但是AND 0必0，OR 1必1，XOR 1取反

移位：影响CF, OF, SF, ZF, PF，而AF不确定。
逻辑移位：可以视为无符号数乘2除2
	SHL 目的操作数，移动位数：左移，移出位进CF，末尾用0填充
		SHL reg/mem, imm8/CL
		OF在左移1位时有效，否则不确定；左移1位后，若符号位改变，OF=1，否则OF=0 
	SHR 目的操作数，移动位数：右移，移出位进CF，最高位用0填充
		SHR reg/mem, imm8/CL
		OF在右移1位时有效，否则不确定；右移1位后符号位改变，OF=1，否则OF=0 
算术移位（移位后正负号 不变 ）
	SAL：同SHL
	SAR 目的操作数，移动位数：目的操作数算术右移，最后移出的位进入CF，高位用符号位填充。
		SAR reg/mem, imm8/CL
		影响CF, OF, SF, ZF, PF，而AF不确定。（?？）
		OF在右移1位时有效，否则不确定；右移1位后，OF=0
		可以视为有符号数除2
循环移位 
	ROR 目的操作数，移动位数：目的操作数循环右移，最后移出的位进CF
	ROL 目的操作数，移动位数：目的操作数循环左移，最后移出的位进CF
		ROL/ROR reg/mem
		影响CF, OF, SF, ZF, PF，而AF不确定。
		OF在左移1位时有效，否则不确定;	左移1位后，若符号位改变，OF=1，否则OF=0
	RCL 目的操作数，移动位数：目的操作数和CF一起循环左移
	RCR目的操作数，移动位数：目的操作数和CF一起循环右移
		RCL reg/mem, imm8/CL
		左\右移1位后，若符号位改变，OF=1，否则OF=0

控制转移类指令
	仅能改变(E)IP，是近转移或段内转移
	能改变(E)IP和CS，是远转移或段间转移

条件控制
	JMP 目标地址：无条件直接转移
		可以用标号表示地址
		JMP NEAR ptr 标号：指明为近转移，目标地址和当前指令在同一个段可省略。（即不改变cs）
		指令中存放的是目标地址的相对位移量，即目标地址和JMP指令的下一条指令（每个指令两字节）的地址的相对位移。用补码表示。
			操作码+相对位移量（从下一条指令的第一个字节从0开始计数，计数为相对位移量时到达目标指令的第一字节）
		JMP SHORT 标号：当相对位移量可以用8位补码表示时，可以这么写(short指示了这是一个短转移)
		JMP Far Ptr 标号 ：指明为远转移，目标地址和当前指令分属不同的段时可省略
	JMP 寄存器\[双字内存]：无条件间接转移、段内\段间间接转移到寄存器中存储的地址
		分远近
	jcc 标号：条件转移，都是段内直接近转移
		条件由CF, PF, AF, ZF, SF, OF组合，形成多达16条条件转移指令。

有没有作用域的说法：在段中定义的变量可以直接用？
字母开头的常数，加0以防与符号混淆

内存中变量名加[]与否不影响定位到变量的内容

循环指令：LOOP对cx的加减不影响标志位
	LOOP 标号：cx-1再判断是否等于0，不等于则跳转，否则结束
	LOOPZ 标号：cx-1，cx!=0 && ZF==1时转移
	LOOPNZ 标号：cx-1，cx!=0 && ZF=0时转移

标志位设置指令
	CL~置0
	ST~置1

其他指令
	NOP:空操作

分支结构
	用条件转移实现

二分支\多分支
	二分支
		then_loc:
		else_loc:
		endif_loc:
	多分支
		直接测试：多个jcc、以jmp end_loc结尾（保证有去向）
		直接地址表：当选项连续，如1234，可以对应几个连续的case，用选项直接表示地址
			JMP	Word Ptr CS: CaseTab [BX]
			CaseTab		DW	Case1, Case2, Case3, Case4, Default
		查找地址表：
			重复n次循环，每次比较输入和一个可选项，相等则进入对应的case，利用选项作为偏移量
			CaseTab	  	DW	'F',Case1,'E',Case2,'V',Case3,'X',Case4
	  					DW	'f',Case1,'e',Case2,'v',Case3,'x',Case4,0,Default

循环结构：实际上也是通过条件控制语句与标志位的调整
	初始化、循环体、调整、控制
	do_while（repeat）结构、while结构
	
.386可以使用eax USE16(地址模式)

MOV 对应大小寄存器,变量名:将变量内容第一个对应变量类型放入对应大小寄存器（[变量]结果一样）
MOV 对应大小寄存器,offset 标号:不能直接标号（操作数不符）

子程序定义与调试
	过程名 PROC [NEAR/FAR]
 	 …			; 子程序代码 
	过程名 ENDP
		① 如调用程序和子程序在同一个代码段中，则使用Near属性。
		② 如调用程序和子程序不在同一个代码段中，则使用Far属性 
	
	CALL\RET	call 子程序名\标号：本地址的下一条指令的地址进栈，jmp到子程序名
				ret [imm]：栈顶弹出目标地址然后转移到该目标地址执行，如果有常数，视为额外的相对偏移量
				far子程序入栈 段地址：EA，按小端排序；near入EA，小端排序；用sp访问栈顶
				直接调用：用子程序名；间接调用：用变量存子程序；也可以call 标号（即不涉及子程序）

寄存器保护与恢复
	主程序和子程序可能的寄存器冲突：入子程序时，把需要用到的寄存器的现有值入栈（保护），退出子程序前出栈放回寄存器（恢复）
	也是解决寄存器不够用的问题
	
参数传递
	通过reg\stack\mem
调用有参数的子程序时，一般栈传参，寄存器传返回值
	参数从左到右压入栈，call子程序，（回到主程序后）add sp,n（n为参数个数：用来还原栈）

call完sp会自增
为什么sp要存到bp：基址变址只能si\di\bp\bx
PUSH的方式：
	先sp移动，再写入移动后的sp
	栈底是浪费的

有符号除法：保持符号位不变，左移，右边用0填充

数据段中的变量：静态变量，在内存中
cs中的变量：动态变量，在栈上
	通过调整栈指针来分配空间
	以 (E)BP为基址，用位移量来存取临时变量（因为动态分配，没有名字）

建立栈帧：
	指从mov bp,sp开始，到sub sp,m的一系列为子程序分配内存的过程
	有enter\leave指令，建立\撤销栈帧

模块化编程：多个源程序，通过public和extern来响应调用和调用（）
	在调用模块时，要指定模块类型（byte、abs、near、far）
	变量、标号或子程序名，及表示常数的符号都可以被声明全局变量（响应调用）

中断指令
	标志寄存器进栈，if\tf置零；中断调用指令后地址的段和偏移地址进栈；
	根据中断的类型号，从中断向量表取中断服务程序入口地址，并转去执行（中断服务子程序的入口地址称为中断向量）
	实模式，内存的最低1KB区域专门用来保存256个中断向量，称为中断向量表 （ea1\seg1、ea2\seg2、ea3\seg3......）
	int imm8\into\iret：根据类型号中断\of==1时进行类型4中断\中断结束，取出ea、seg、16位flags，转移地址并放回flags
	sti开中断、cli关中断：设置标记位if等
	
中断优先级
直接内存存取dma

MAIN 子程序用far（历史遗留问题）
其他的子程序用NEAR

call FAR PTR 子程序名：来段间调用

MASM10.0\ML //coff /c  /Zd   /Zi  f2.asm	从而允许vs中debug进入汇编文件 

or\and al,al：检查al是否为0（对al的值没有影响）
